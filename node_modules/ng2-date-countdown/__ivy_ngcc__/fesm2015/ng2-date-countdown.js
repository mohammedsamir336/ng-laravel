import { __decorate } from 'tslib';
import { EventEmitter, Input, Output, Component, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function CountDown_div_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 5);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r3.divider, " ");
} }
function CountDown_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "p", 2);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, CountDown_div_1_span_3_Template, 2, 1, "span", 3);
    ɵngcc0.ɵɵelementStart(4, "p", 4);
    ɵngcc0.ɵɵtext(5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const time_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMapInterpolate1("measurements ", time_r1, "");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r0.showZero && ctx_r0.displayNumbers[i_r2] < 10 ? "0" + ctx_r0.displayNumbers[i_r2].trim() : ctx_r0.displayNumbers[i_r2], " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.display[i_r2 + 1]);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", time_r1, " ");
} }
const _c0 = ["*"];
let CountDown = class CountDown {
    constructor() {
        this.displayString = '';
        this.showZero = false;
        this.reached = new EventEmitter();
        this.display = [];
        this.displayNumbers = [];
        this.wasReached = false;
        setInterval(() => this._displayString(), 100);
    }
    _displayString() {
        if (this.wasReached)
            return;
        if (typeof this.units === 'string') {
            this.units = this.units.split('|');
        }
        let givenDate = new Date(this.end);
        let now = new Date();
        let dateDifference = givenDate - now;
        if ((dateDifference < 100 && dateDifference > 0) || dateDifference < 0 && !this.wasReached) {
            this.wasReached = true;
            this.reached.next(now);
        }
        let lastUnit = this.units[this.units.length - 1], unitConstantForMillisecs = {
            year: (((1000 * 60 * 60 * 24 * 7) * 4) * 12),
            month: ((1000 * 60 * 60 * 24 * 7) * 4),
            weeks: (1000 * 60 * 60 * 24 * 7),
            days: (1000 * 60 * 60 * 24),
            hours: (1000 * 60 * 60),
            minutes: (1000 * 60),
            seconds: 1000
        }, unitsLeft = {}, returnText = '', returnNumbers = '', totalMillisecsLeft = dateDifference, i, unit;
        for (i in this.units) {
            if (this.units.hasOwnProperty(i)) {
                unit = this.units[i].trim();
                if (unitConstantForMillisecs[unit.toLowerCase()] === false) {
                    //$interval.cancel(countDownInterval);
                    throw new Error('Cannot repeat unit: ' + unit);
                }
                if (unitConstantForMillisecs.hasOwnProperty(unit.toLowerCase()) === false) {
                    throw new Error('Unit: ' + unit + ' is not supported. Please use following units: year, month, weeks, days, hours, minutes, seconds, milliseconds');
                }
                // If it was reached, everything is zero
                unitsLeft[unit] = (this.wasReached) ? 0 : totalMillisecsLeft / unitConstantForMillisecs[unit.toLowerCase()];
                if (lastUnit === unit) {
                    unitsLeft[unit] = Math.ceil(unitsLeft[unit]);
                }
                else {
                    unitsLeft[unit] = Math.floor(unitsLeft[unit]);
                }
                totalMillisecsLeft -= unitsLeft[unit] * unitConstantForMillisecs[unit.toLowerCase()];
                unitConstantForMillisecs[unit.toLowerCase()] = false;
                // If it's less than 0, round to 0
                unitsLeft[unit] = (unitsLeft[unit] > 0) ? unitsLeft[unit] : 0;
                returnNumbers += ' ' + unitsLeft[unit] + ' | ';
                returnText += ' ' + unit;
            }
        }
        if (this.text === null || !this.text) {
            this.text = {
                Year: 'Year',
                Month: 'Month',
                Weeks: 'Weeks',
                Days: 'Days',
                Hours: 'Hours',
                Minutes: 'Minutes',
                Seconds: 'Seconds',
                MilliSeconds: 'Milliseconds'
            };
        }
        this.displayString = returnText
            .replace('Year', this.text.Year + ' | ')
            .replace('Month', this.text.Month + ' | ')
            .replace('Weeks', this.text.Weeks + ' | ')
            .replace('Days', this.text.Days + ' | ')
            .replace('Hours', this.text.Hours + ' | ')
            .replace('Minutes', this.text.Minutes + ' | ')
            .replace('Seconds', this.text.Seconds);
        this.displayNumbers = returnNumbers.split('|');
        this.display = this.displayString.split('|');
    }
};
CountDown.ɵfac = function CountDown_Factory(t) { return new (t || CountDown)(); };
CountDown.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CountDown, selectors: [["countdown"]], inputs: { displayString: "displayString", showZero: "showZero", units: "units", text: "text", end: "end", divider: "divider" }, outputs: { reached: "reached" }, ngContentSelectors: _c0, decls: 3, vars: 1, consts: [[1, "countdown"], [3, "class", 4, "ngFor", "ngForOf"], [1, "measurements-number"], ["class", "divider", 4, "ngIf"], [1, "measurements-text"], [1, "divider"]], template: function CountDown_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, CountDown_div_1_Template, 6, 6, "div", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.display);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf], styles: [".countdown[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;align-content:center;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif}.countdown[_ngcontent-%COMP%]   .measurements[_ngcontent-%COMP%]{flex:.1}.countdown[_ngcontent-%COMP%]   .measurements[_ngcontent-%COMP%]   .divider[_ngcontent-%COMP%]{float:right}"] });
__decorate([
    Input()
], CountDown.prototype, "units", void 0);
__decorate([
    Input()
], CountDown.prototype, "end", void 0);
__decorate([
    Input()
], CountDown.prototype, "displayString", void 0);
__decorate([
    Input()
], CountDown.prototype, "text", void 0);
__decorate([
    Input()
], CountDown.prototype, "divider", void 0);
__decorate([
    Input()
], CountDown.prototype, "showZero", void 0);
__decorate([
    Output()
], CountDown.prototype, "reached", void 0);

let CountdownModule = class CountdownModule {
};
CountdownModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: CountdownModule });
CountdownModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function CountdownModule_Factory(t) { return new (t || CountdownModule)(); }, imports: [[
            CommonModule
        ]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CountDown, [{
        type: Component,
        args: [{
                selector: 'countdown',
                template: "<div class=\"countdown\">\n  <div *ngFor=\"let time of display; let i = index\" class=\"measurements {{time}}\">\n    <p class=\"measurements-number\">\n      {{ (showZero && displayNumbers[i] < 10) ? '0' + displayNumbers[i].trim() : displayNumbers[i]}}\n    </p>\n    <span *ngIf=\"display[i+1]\" class=\"divider\"> {{divider}} </span>\n    <p class=\"measurements-text\">\n      {{time}}\n    </p>\n  </div>\n</div>\n<ng-content></ng-content>\n",
                styles: [".countdown{display:flex;align-items:center;justify-content:center;align-content:center;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif}.countdown .measurements{flex:.1}.countdown .measurements .divider{float:right}"]
            }]
    }], function () { return []; }, { displayString: [{
            type: Input
        }], showZero: [{
            type: Input
        }], reached: [{
            type: Output
        }], units: [{
            type: Input
        }], text: [{
            type: Input
        }], end: [{
            type: Input
        }], divider: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(CountdownModule, { declarations: function () { return [CountDown]; }, imports: function () { return [CommonModule]; }, exports: function () { return [CountDown]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(CountdownModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    CountDown
                ],
                exports: [
                    CountDown
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { CountDown, CountdownModule };

//# sourceMappingURL=ng2-date-countdown.js.map